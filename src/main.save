extern crate config;
extern crate handlebars_iron as hbs;
extern crate iron;

#[macro_use]
extern crate lazy_static;

mod settings;

use config::{Config, Environment, File};
use std::collections::HashMap;
use std::env;
use std::error::Error;

use log::{debug, info};

use iron::prelude::{Chain, Iron, Request, Response};
use iron::{status, Set};

// Load config file(s) into global static SETTINGS
lazy_static! {
    static ref SETTINGS: Config = {
        let mut settings = Config::default();
        let env = env::var("RUN_MODE").unwrap_or("development".into());

        settings
            .merge(File::with_name("conf/default"))
            .unwrap()
            .merge(File::with_name(&format!("conf/{}", env)).required(false))
            .unwrap()
            .merge(File::with_name("conf/local").required(false))
            .unwrap()
            .merge(Environment::with_prefix("app"))
            .unwrap();
        settings.try_into()
    };
}

fn main() {
    setup_logging();
    start_webservice();
}

fn setup_logging() {
    simple_logger::init_with_level(log::Level::Trace).unwrap();
    debug!(
        "SETTINGS: {:?}",
        SETTINGS.clone().try_into() //::<HashMap<String, String>>()
                                    //            .unwrap()
    );
    let run_level = SETTINGS
        .get_str("run_level")
        .expect("Missing run_level in config");
    info!("Running as run_level {}", run_level);
}

fn start_webservice() {
    // setup Handlebars templating directory
    let mut hbse = hbs::HandlebarsEngine::new();
    hbse.add(Box::new(hbs::DirectorySource::new("./src/view/", ".hbs")));
    if let Err(r) = hbse.reload() {
        panic!("{:?}", r.description());
    }

    //
    let mut chain = Chain::new(|_: &mut Request| {
        let mut resp = Response::new();
        resp.set_mut(hbs::Template::new("index", "".to_string()))
            .set_mut(status::Ok);
        Ok(resp)
    });
    chain.link_after(hbse);

    // start iron webservice
    let bind_address = SETTINGS
        .get_str("webservice.bind_address")
        .expect("Missing webservice.bind_address in config");
    let bind_port = SETTINGS
        .get_str("webservice.bind_port")
        .expect("Missing webservice.bind_port in config");
    let _server_guard = Iron::new(chain)
        .http(format!("{}:{}", bind_address, bind_port))
        .unwrap();
    let version = include_str!("version.txt");

    info!(
        "Listening on {}:{} as version {}",
        bind_address, bind_port, version
    );
}
